/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { Coin, StdFee } from "@cosmjs/amino";
import {
  CosmWasmClient,
  ExecuteResult,
  SigningCosmWasmClient,
} from "@cosmjs/cosmwasm-stargate";
import {
  CollectedFeesResponse,
  EscrowResponse,
  EscrowsResponse,
  Uint128,
} from "./Escrow.types";

export interface EscrowReadOnlyInterface {
  contractAddress: string;
  getEscrow: ({ escrowId }: { escrowId: number }) => Promise<EscrowResponse>;
  getCollectedFees: () => Promise<CollectedFeesResponse>;
  getEscrows: ({
    caller,
    limit,
    provider,
    startAfter,
  }: {
    caller?: string;
    limit?: number;
    provider?: string;
    startAfter?: number;
  }) => Promise<EscrowsResponse>;
}

export class EscrowQueryClient implements EscrowReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getEscrow = this.getEscrow.bind(this);
    this.getCollectedFees = this.getCollectedFees.bind(this);
    this.getEscrows = this.getEscrows.bind(this);
  }
  getEscrow = async ({
    escrowId,
  }: {
    escrowId: number;
  }): Promise<EscrowResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_escrow: {
        escrow_id: escrowId,
      },
    });
  };
  getCollectedFees = async (): Promise<CollectedFeesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_collected_fees: {},
    });
  };
  getEscrows = async ({
    caller,
    limit,
    provider,
    startAfter,
  }: {
    caller?: string;
    limit?: number;
    provider?: string;
    startAfter?: number;
  }): Promise<EscrowsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_escrows: {
        caller,
        limit,
        provider,
        start_after: startAfter,
      },
    });
  };
}

export interface EscrowInterface extends EscrowReadOnlyInterface {
  contractAddress: string;
  sender: string;
  lockFunds: (
    {
      authToken,
      expires,
      maxFee,
      toolId,
    }: {
      authToken: string;
      expires: number;
      maxFee: Uint128;
      toolId: string;
    },
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: Coin[]
  ) => Promise<ExecuteResult>;
  release: (
    {
      escrowId,
      usageFee,
    }: {
      escrowId: number;
      usageFee: Uint128;
    },
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: Coin[]
  ) => Promise<ExecuteResult>;
  refundExpired: (
    {
      escrowId,
    }: {
      escrowId: number;
    },
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: Coin[]
  ) => Promise<ExecuteResult>;
  claimFees: (
    {
      denom,
    }: {
      denom?: string;
    },
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: Coin[]
  ) => Promise<ExecuteResult>;
}

export class EscrowClient extends EscrowQueryClient implements EscrowInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(
    client: SigningCosmWasmClient,
    sender: string,
    contractAddress: string
  ) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.lockFunds = this.lockFunds.bind(this);
    this.release = this.release.bind(this);
    this.refundExpired = this.refundExpired.bind(this);
    this.claimFees = this.claimFees.bind(this);
  }
  lockFunds = async (
    {
      authToken,
      expires,
      maxFee,
      toolId,
    }: {
      authToken: string;
      expires: number;
      maxFee: Uint128;
      toolId: string;
    },
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        lock_funds: {
          auth_token: authToken,
          expires,
          max_fee: maxFee,
          tool_id: toolId,
        },
      },
      fee_,
      memo_,
      funds_
    );
  };
  release = async (
    {
      escrowId,
      usageFee,
    }: {
      escrowId: number;
      usageFee: Uint128;
    },
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        release: {
          escrow_id: escrowId,
          usage_fee: usageFee,
        },
      },
      fee_,
      memo_,
      funds_
    );
  };
  refundExpired = async (
    {
      escrowId,
    }: {
      escrowId: number;
    },
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        refund_expired: {
          escrow_id: escrowId,
        },
      },
      fee_,
      memo_,
      funds_
    );
  };
  claimFees = async (
    {
      denom,
    }: {
      denom?: string;
    },
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        claim_fees: {
          denom,
        },
      },
      fee_,
      memo_,
      funds_
    );
  };
}
