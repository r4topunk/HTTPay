/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import { Coin, StdFee } from "@cosmjs/amino";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import {
  useMutation,
  UseMutationOptions,
  useQuery,
  UseQueryOptions,
} from "@tanstack/react-query";
import { EscrowClient, EscrowQueryClient } from "./Escrow.client";
import {
  CollectedFeesResponse,
  EscrowResponse,
  EscrowsResponse,
  Uint128
} from "./Escrow.types";

export const escrowQueryKeys = {
  contract: [
    {
      contract: "escrow",
    },
  ] as const,
  address: (contractAddress: string | undefined) =>
    [
      {
        ...escrowQueryKeys.contract[0],
        address: contractAddress,
      },
    ] as const,
  getEscrow: (
    contractAddress: string | undefined,
    args?: Record<string, unknown>
  ) =>
    [
      {
        ...escrowQueryKeys.address(contractAddress)[0],
        method: "get_escrow",
        args,
      },
    ] as const,
  getCollectedFees: (
    contractAddress: string | undefined,
    args?: Record<string, unknown>
  ) =>
    [
      {
        ...escrowQueryKeys.address(contractAddress)[0],
        method: "get_collected_fees",
        args,
      },
    ] as const,
  getEscrows: (
    contractAddress: string | undefined,
    args?: Record<string, unknown>
  ) =>
    [
      {
        ...escrowQueryKeys.address(contractAddress)[0],
        method: "get_escrows",
        args,
      },
    ] as const,
};

export interface EscrowReactQuery<TResponse, TData = TResponse> {
  client: EscrowQueryClient | undefined;
  options?: Omit<
    UseQueryOptions<TResponse, Error, TData>,
    "'queryKey' | 'queryFn' | 'initialData'"
  > & {
    initialData?: undefined;
  };
}

export interface EscrowGetEscrowsQuery<TData>
  extends EscrowReactQuery<EscrowsResponse, TData> {
  args: {
    caller?: string;
    limit?: number;
    provider?: string;
    startAfter?: number;
  };
}

export function useEscrowGetEscrowsQuery<TData = EscrowsResponse>({
  client,
  args,
  options,
}: EscrowGetEscrowsQuery<TData>) {
  return useQuery<EscrowsResponse, Error, TData>(
    escrowQueryKeys.getEscrows(client?.contractAddress, args),
    () =>
      client
        ? client.getEscrows({
            caller: args.caller,
            limit: args.limit,
            provider: args.provider,
            startAfter: args.startAfter,
          })
        : Promise.reject(new Error("Invalid client")),
    {
      ...options,
      enabled:
        !!client && (options?.enabled != undefined ? options.enabled : true),
    }
  );
}

export interface EscrowGetCollectedFeesQuery<TData>
  extends EscrowReactQuery<CollectedFeesResponse, TData> {}

export function useEscrowGetCollectedFeesQuery<TData = CollectedFeesResponse>({
  client,
  options,
}: EscrowGetCollectedFeesQuery<TData>) {
  return useQuery<CollectedFeesResponse, Error, TData>(
    escrowQueryKeys.getCollectedFees(client?.contractAddress),
    () =>
      client
        ? client.getCollectedFees()
        : Promise.reject(new Error("Invalid client")),
    {
      ...options,
      enabled:
        !!client && (options?.enabled != undefined ? options.enabled : true),
    }
  );
}

export interface EscrowGetEscrowQuery<TData>
  extends EscrowReactQuery<EscrowResponse, TData> {
  args: {
    escrowId: number;
  };
}

export function useEscrowGetEscrowQuery<TData = EscrowResponse>({
  client,
  args,
  options,
}: EscrowGetEscrowQuery<TData>) {
  return useQuery<EscrowResponse, Error, TData>(
    escrowQueryKeys.getEscrow(client?.contractAddress, args),
    () =>
      client
        ? client.getEscrow({
            escrowId: args.escrowId,
          })
        : Promise.reject(new Error("Invalid client")),
    {
      ...options,
      enabled:
        !!client && (options?.enabled != undefined ? options.enabled : true),
    }
  );
}

export interface EscrowClaimFeesMutation {
  client: EscrowClient;
  msg: {
    denom?: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}

export function useEscrowClaimFeesMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, EscrowClaimFeesMutation>,
    "mutationFn"
  >
) {
  return useMutation<ExecuteResult, Error, EscrowClaimFeesMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.claimFees(msg, fee, memo, funds),
    options
  );
}

export interface EscrowRefundExpiredMutation {
  client: EscrowClient;
  msg: {
    escrowId: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}

export function useEscrowRefundExpiredMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, EscrowRefundExpiredMutation>,
    "mutationFn"
  >
) {
  return useMutation<ExecuteResult, Error, EscrowRefundExpiredMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.refundExpired(msg, fee, memo, funds),
    options
  );
}

export interface EscrowReleaseMutation {
  client: EscrowClient;
  msg: {
    escrowId: number;
    usageFee: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}

export function useEscrowReleaseMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, EscrowReleaseMutation>,
    "mutationFn"
  >
) {
  return useMutation<ExecuteResult, Error, EscrowReleaseMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.release(msg, fee, memo, funds),
    options
  );
}

export interface EscrowLockFundsMutation {
  client: EscrowClient;
  msg: {
    authToken: string;
    expires: number;
    maxFee: Uint128;
    toolId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}

export function useEscrowLockFundsMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, EscrowLockFundsMutation>,
    "mutationFn"
  >
) {
  return useMutation<ExecuteResult, Error, EscrowLockFundsMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.lockFunds(msg, fee, memo, funds),
    options
  );
}
